---
title: "Performance notes"
output: html_document
---

There could be several ways to do stuff. Which one is faster?
See [comparison of single value
assignment](https://github.com/gagin/R-tricks/blob/master/compare-dt-df.R)
in data.frame, data.table and list. It seems that it's faster to read from
higher level construct but write to lower level construct.

```{r, include=FALSE}
library(microbenchmark)
library(ggplot2)
library(magrittr)
library(data.table)
```

## Is magrittr's two-way pipe syntax good?

Magrittr two way pipe syntax looks convenient, as one doesn't need to
write a variable name twice if something is applied to it. But I experienced
it to slow a cycle significantly in a project of mine. Is it slow indeed? What
about one-way pipe operator, is that one slow as well? Is it different in dplyr,
if dplyr imports magrittr's namespace?

Seems that pipe is at least 10 times slower than straight assignment (and dplyr
just reexports magrittr's operator) - and so it can be used between functions
that handle frames, but not inside of cycles.

```{r}
m <- matrix(c(1,2,3,4),nrow=2)

library(dplyr, quietly=TRUE, warn.conflicts = FALSE);
mb.dplyr <- microbenchmark(
        m <- m %>% t,
        m <- t(m),
        times=10000L
)
mb.dplyr
autoplot(mb.dplyr)

library(magrittr, quietly=TRUE);
mb.magrittr <- microbenchmark(
        m %<>% t,
        m <- m %>% t,
        m <- t(m),
        times=10000L
)
mb.magrittr
autoplot(mb.magrittr)
```

## Strsplit is faster than regexp

```{r}
cleanup.strsplit.NA <- function(s) {
        # This one is broken - it will return NA if the split isn't found
        strsplit(x=s, split="oz.) ", fixed=TRUE)[[1]][2]
}

cleanup.strsplit <- function(s) {
        s1 <- strsplit(x=s, split="oz.) ", fixed=TRUE)[[1]][2]
        if(is.na(s1)) s else s1
}

cleanup.sub <- function(s) {
        sub("(.+oz\\.\\) )(.+)", "\\2", s)
}

l <- rep(c("simple","(   oz.) tomato paste"),10)
microbenchmark(
        lapply(l,cleanup.sub),
        lapply(l,cleanup.strsplit),
        lapply(l,cleanup.strsplit.NA),
        times=1000L
        ) %>%
        autoplot
```

## row.names vs rownames

In the experiment below,

* rownames are faster for matrix for both read and write,
* it doesn't matter for data.table and data.frame, although row.names is a bit
faster

Interesingly, there're row.names and rownames, but there's only colnames.
There's no col.names

TODO Check if there are confidence intervals built-in in microbenchmark(),
and implement, if they aren't

```{r, echo=FALSE}
m <- matrix(1:10000, ncol=1, nrow=10000, dimnames=list(1:10000))
m1 <- m
mb.matrix <- microbenchmark(
        row.names(m1) <- row.names(m),
        row.names(m1) <- rownames(m),
        rownames(m1) <- row.names(m),
        rownames(m1) <- rownames(m),
        times = 1000L)     
autoplot(mb.matrix)
mb.matrix

df <- data.frame(m)
df1 <- df
mb.df<-microbenchmark(
        row.names(df1) <- row.names(df),
        row.names(df1) <- rownames(df),
        rownames(df1) <- row.names(df),
        rownames(df1) <- rownames(df),
        times = 1000L)
autoplot(mb.df)
mb.df

dt <- data.table(m)
dt1 <- dt
mb.dt<-microbenchmark(
        row.names(dt1) <- row.names(dt),
        row.names(dt1) <- rownames(dt),
        rownames(dt1) <- row.names(dt),
        rownames(dt1) <- rownames(dt),
        times = 1000L)
autoplot(mb.dt)
mb.dt
```

## Apply vs for loop

Technically, apply function do the same thing as for loops, but if something
can be organized to be used in apply(), then it's probably more efficient
as well.